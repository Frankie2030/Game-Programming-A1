# Whack-a-Zombie ‚Äî Assignment 1

A Python-based whack-a-mole style game built with Pygame, featuring zombies that emerge from tombstones in a spooky graveyard setting.

# Features

Whack-a-Zombie is an arcade-style game where players must click on zombie heads as they emerge from tombstones. The game features:

- **20 spawn points** arranged in a 4x5 grid matching background tombstones
- **Progressive difficulty** with level-based scaling
- **Brain pickups** that grant extra lives
- **Comprehensive HUD** showing score, accuracy, and progress
- **Audio support** with background music and sound effects

# Quick Start

## Prerequisites

- Python 3.8 or higher
- Pygame library

## Installation

1. Clone or download the project files
2. Navigate to the project directory
3. Add environment & Install dependencies:

```bash
python3 -m venv venv
source venv/bin/activate
python3 -m pip install -r requirements.txt
```

## Running the Game

```bash
python3 main.py
```

## Build the executable file .exe

```bash
python3 -m pip install pyinstaller
pyinstaller --onefile --windowed --name "WhackZombie" --add-data "assets:assets" main.py 
```

# Game Controls

| Key | Action |
|-----|--------|
| **Left Mouse Button** | Whack zombies / Collect brains |
| **P** | Pause / Resume game |
| **F** | Toggle FPS display |
| **R** | Reset current run |
| **M** | Mute / Unmute audio |
| **ESC** | Quit game |
| **SPACE/ENTER** | Start game (from start screen) |

# Asset Sources
- [Zombie design](https://github.com/aayush-musyaju/plant-vs-zombies/tree/main/public/assets/images/Zombies)
- Background: Generated by Gemini
- [SFX](https://github.com/ULTIMATE-Mystery/Game-programming-HCMUT-Semester-222/tree/Assignment-1/Resources/sounds)
- [BGM: 02 - Trauma Resort (chase, fight)](https://rustedstudio.itch.io/free-music-apocalypse-z)

---

# Rubric-based Features

## Required Features

### Background with multiple zombie spawn locations - 2 pts

**Requirement**: Provide a background scene with several distinct positions where zombies can appear. Recommendation: at least 6 clearly separated spawn points distributed across the playfield.

**Implementation**:

The game features 20 spawn points (4 rows √ó 5 columns) positioned to align with tombstones in the background image.

**Details**: 

- **20 spawn points** arranged in a **4√ó5 grid** (exceeds requirement of 6)
- Background image: `assets/game_background.png` with tombstone graphics
- Spawn points positioned at pixel coordinates aligned with tombstones
- Responsive positioning that scales with window resizing
- SpawnPoint model with position and radius attributes

```python
# main.py
def make_spawn_points(self) -> list[SpawnPoint]:
    """20 spawn points (4 rows x 5 columns) positioned to align with tombs."""
    cols, rows = 5, 4
    start_x, start_y = 160, 75
    x_gap, y_gap = 155, 115
    base_positions = [
        (start_x + col * x_gap, start_y + row * y_gap)
        for row in range(rows)
        for col in range(cols)
    ]
    
    spawn_points = []
    for pos in spawn_positions:
        spawn_points.append(SpawnPoint(pos, radius=SPAWN_RADIUS))
    return spawn_points
```

```python
# src/constants.py
BACKGROUND_PATH = os.path.join(ASSETS_DIR, "game_background.png")
```

---

### Zombie design (sprite/art) - 1 pt

**Requirement**: Include a distinct zombie visual (head or full body). Ensure consistent art style; credit sources if you use third-party assets.

**Implementation**:

Zombies use a sprite sheet with multiple animation frames for idle, attack, and death states.

**Assets**: `assets/ZombieSprite_166x144.png` - sprite sheet with multiple zombie states

**Details**:

- Multiple animated sprite frames for different states (normal, attack, death)
- Consistent pixel art style throughout

```python
# src/zombie.py
@classmethod
def load_sprites(cls):
    if os.path.exists(ZOMBIE_SPRITE_PATH):
        cls.sprite_sheet = pygame.image.load(ZOMBIE_SPRITE_PATH).convert_alpha()
        # Extract normal, attack, and death frames from sprite sheet
        normal_positions = [(0, 0), (1, 0), (2, 0), (3, 0), (0, 1), (1, 1), (2, 1), (3, 1)]
        attack_positions = [(4, 2), (5, 2), (6, 2), (7, 2)]
        death_positions = [(0, 10), (1, 10), (2, 10), (3, 10)]
```

---

### Zombie head display and lifetime - 2 pts

**Requirement**: 

- 1 pt: The zombie head appears and persists until hit (no auto-disappear)
- 2 pts: The zombie head has a timer and automatically disappears after a set duration. Use different durations to vary difficulty

**Implementation** (2 pts achieved):

Zombies have configurable lifetimes and automatically attack (dealing damage) after their timer expires.

**Details**:

- **Timer-based system**: Zombies have configurable lifetime (800-2000ms range)
- **Visual timer bar** above each zombie showing remaining time
- **Level-based scaling**: Lifetime decreases as level increases
- **Auto-attack**: Zombies attack when timer expires (if not hit)
- **Animation states**: Spawn ‚Üí Active ‚Üí Attack/Hit ‚Üí Despawn


```python
# src/zombie.py
def update(self, now_ms: int) -> bool:
    attack_occurred = False
    
    # Auto-attack when lifetime expires
    if not self.hit and not self.attacking and (now_ms - self.born_at >= self.lifetime):
        self.start_attack(now_ms)
    
    # Deal damage after attack animation completes
    if self.attacking and now_ms - self.attack_start >= ATTACK_ANIM_MS:
        attack_occurred = True
        self.has_dealt_damage = True
        self.despawn_start = now_ms
    
    return attack_occurred
```

```python
# src/constants.py
MAX_LIFETIME_MS = 2000
MIN_LIFETIME_MS = 800
ATTACK_ANIM_MS = 300
LEVEL_LIFETIME_DECREASE = 100  # ms per level

# src/spawner.py - lifetime calculation
lifetime = MAX_LIFETIME_MS - (level - 1) * LEVEL_LIFETIME_DECREASE
lifetime = max(MIN_ZOMBIE_LIFETIME, lifetime)
```

Difficulty scaling with faster spawns and shorter zombie lifetimes.

```python
# src/spawner.py
def get_spawn_interval(self, level: int) -> int:
    """Calculate spawn interval based on level."""
    return max(MIN_SPAWN_INTERVAL, SPAWN_INTERVAL_MS - (level - 1) * LEVEL_SPAWN_DECREASE)

def maybe_spawn(self, now_ms: int, zombies: list[Zombie], level: int) -> None:
    if available_spawns:
        lifetime = MAX_LIFETIME_MS - (level - 1) * LEVEL_LIFETIME_DECREASE
        lifetime = max(MIN_ZOMBIE_LIFETIME, lifetime)
        new_zombie = Zombie(spawn, born_at_ms=now_ms, lifetime_ms=lifetime)
```

```python
# main.py
def update_level(self) -> None:
    """Update game level based on zombies killed."""
    new_level = min(MAX_LEVEL, (self.hits // ZOMBIES_PER_LEVEL) + 1)
    if new_level > self.level:
        self.level = new_level
        # Award +1 life on level up
        self.lives = min(MAX_LIVES, self.lives + 1)
```
---

### Mouse interaction / hit detection - 3 pts

**Requirement**: Capture mouse click events at coordinates (x, y). Determine whether the click hits the zombie's head (use a hitbox or pixel-perfect test). Prevent double-counting on a single click; ignore clicks while animations are finishing.

**Implementation**:

Comprehensive click handling with rectangle-based hit detection and priority system.

**Details**:

- **Rectangle-based hitbox detection** for precise collision
- **Priority system**: Brain pickups checked before zombies
- **State-based protection**: No hits during attack animations
- **Single-hit prevention**: Zombies marked as hit immediately
- **Comprehensive logging**: All clicks logged with coordinates and results
- **Debug mode**: Visual hitbox display (press 'B')

```python
# main.py
def handle_click(self, pos: tuple[int, int], now_ms: int) -> None:
    # Check brain pickups first (higher priority)
    for brain in reversed(self.brains):
        if not brain.picked_up and not brain.dead and brain.contains_point(pos):
            brain.mark_picked_up(now_ms)
            self.lives = min(MAX_LIVES, self.lives + 1)
            return
    
    # Check zombie hits
    for z in reversed(self.zombies):
        if not z.hit and not z.attacking and z.contains_point(pos, now_ms):
            z.mark_hit(now_ms)
            self.hits += 1
            return
    
    # No hit registered
    self.misses += 1
```

```python
# src/zombie.py
def contains_point(self, point: tuple[int, int], now_ms: int) -> bool:
    if self.attacking:  # Prevent hits during attack animation
        return False
    hitbox_rect = self.get_hitbox_rect(now_ms)
    return hitbox_rect.collidepoint(point)

def get_hitbox_rect(self, now_ms: int) -> pygame.Rect:
    sprite_width, sprite_height = self._scaled_size()
    hitbox_rect = pygame.Rect(0, 0, int(sprite_width * 0.5), int(sprite_height * 0.9))
    hitbox_rect.centerx = center[0]
    hitbox_rect.centery = center[1] + vertical_offset
    return hitbox_rect
```

---

### Score output (HUD) - 2 pts

**Requirement**: 

- 1 pt: Display either hits or misses
- 2 pts: Display both hits and misses, and show a differential or ratio (accuracy percent)

**Implementation** (2 pts achieved):

Comprehensive HUD displaying hits, misses, accuracy percentage, level, and lives.

**Details**:

- **Comprehensive statistics**: Hits, misses, accuracy percentage
- **Level progression**: Current level and progress toward next level
- **Lives system**: Visual brain icons showing remaining lives
- **Responsive layout**: Left/right split design that adapts to window size
- **Additional metrics**: Level, zombies killed progress
- **Real-time updates**: All stats update immediately on game events

```python
# ui.py
def draw(self, surf: pygame.Surface, hits: int, misses: int, lives: int, level: int):
    total = hits + misses
    acc = (hits / total * 100.0) if total > 0 else 0.0
    
    # Right side stats
    right_stats = [
        f"Hits: {hits}",
        f"Misses: {misses}",
        f"Accuracy: {acc:.1f}%",
    ]
    
    # Left side level/lives display
    level_text = self.font.render(f"Level: {level}", True, TEXT_COLOR)
    # Brain icon + lives count display
```

## Bonus Features

### Audio

Background music, hit sound effects, and level-up sounds with volume controls.

**Methods**: 

- `Game.init_audio()` 
- `Game.toggle_mute()` 

**Features**:

- **Background music**: Looped ambient music
- **Hit sound effects**: Distinct sound when zombies are hit
- **Level-up audio**: Special sound for level progression
- **Volume controls**: Separate BGM and SFX volume sliders on start screen
- **Mute toggle**: 'M' key to mute/unmute all audio

```python
# main.py
def init_audio(self) -> None:
    if os.path.exists(MUSIC_PATH):
        pygame.mixer.music.load(MUSIC_PATH)
        pygame.mixer.music.play(-1)  # Loop indefinitely
    
    if os.path.exists(HIT_SFX_PATH):
        self.snd_hit = pygame.mixer.Sound(HIT_SFX_PATH)
    
    if os.path.exists(LEVEL_UP_SFX_PATH):
        self.snd_level_up = pygame.mixer.Sound(LEVEL_UP_SFX_PATH)
```

---

### Hit Effects

Particle effects for both zombie hits and hammer strikes with color-coded feedback.

Note: `alpha` l√† gi√° tr·ªã bi·ªÉu th·ªã ƒë·ªô trong su·ªët c·ªßa m·ªôt m√†u ho·∫∑c b·ªÅ m·∫∑t (surface). Gi√° tr·ªã alpha n·∫±m trong kho·∫£ng t·ª´ 0 (ho√†n to√†n trong su·ªët) ƒë·∫øn 255 (ho√†n to√†n ƒë·ª•c).

**Methods**: 

- `Game.create_hammer_hit_effect()` 
- `Zombie.create_hit_effects()`
- `Game.draw_life_loss_flash()`

**Features**:

- **Hammer impact particles**: Sparks and dust on every click
- **Zombie hit particles**: Colorful explosion when zombies are hit
- **Screen flash effects**: Red flash when losing lives
- **Hit flash**: Zombies flash white when hit

```python
# src/zombie.py
def create_hit_effects(self, hit_pos: tuple[int, int]) -> None:
    for _ in range(12):
        angle = random.uniform(0, 2 * math.pi)
        speed = random.uniform(1, 3)
        particle = {
            'x': hit_pos[0], 'y': hit_pos[1],
            'dx': math.cos(angle) * speed,
            'dy': math.sin(angle) * speed,
            'life': random.randint(80, 120),
            'alpha': 255
        }
        self.hit_particles.append(particle)
```

```python
# main.py
def draw_life_loss_flash(self) -> None:
    """Draw screen flash when life is lost."""
    if self.life_lost_flash > 0:
        alpha = int(100 * (self.life_lost_flash / LIFE_LOSS_FLASH_MS))
        flash_surface = pygame.Surface((self.current_width, self.current_height), pygame.SRCALPHA)
        flash_surface.fill((255, 0, 0, alpha))
        self.screen.blit(flash_surface, (0, 0))
```

- Gi√° tr·ªã alpha ƒë∆∞·ª£c t√≠nh d·ª±a tr√™n t·ª∑ l·ªá th·ªùi gian c√≤n l·∫°i c·ªßa hi·ªáu ·ª©ng (self.life_lost_flash) so v·ªõi th·ªùi gian t·ªëi ƒëa (LIFE_LOSS_FLASH_MS). K·∫øt qu·∫£ l√† m·ªôt gi√° tr·ªã t·ª´ 0 (khi hi·ªáu ·ª©ng k·∫øt th√∫c) ƒë·∫øn 100 (khi hi·ªáu ·ª©ng b·∫Øt ƒë·∫ßu), t·∫°o hi·ªáu ·ª©ng m·ªù d·∫ßn.
- T·∫°o m·ªôt pygame.Surface v·ªõi k√≠ch th∆∞·ªõc b·∫±ng k√≠ch th∆∞·ªõc m√†n h√¨nh (self.current_width, self.current_height) v√† c·ªù pygame.SRCALPHA ƒë·ªÉ h·ªó tr·ª£ ƒë·ªô trong su·ªët.
- ƒê·ªï m√†u ƒë·ªè (255, 0, 0, alpha) l√™n surface n√†y.
- V·∫Ω surface l√™n m√†n h√¨nh t·∫°i v·ªã tr√≠ (0, 0) b·∫±ng self.screen.blit.

```python
def create_hammer_hit_effect(self, hit_pos: tuple[int, int]) -> None:
    """Create hammer hit effect at click position."""
    
    # Create impact particles
    for _ in range(8):
        angle = random.uniform(0, 2 * math.pi)
        speed = random.uniform(1, 3)  # Reduced speed for better visibility
        dx = math.cos(angle) * speed
        dy = math.sin(angle) * speed
        effect = {
            'x': hit_pos[0],
            'y': hit_pos[1],
            'dx': dx,
            'dy': dy,
            'life': random.randint(80, 120),  # Increased lifetime
            'max_life': 120,  # Increased max lifetime
            'alpha': 255,
            'size': random.randint(3, 6),  # Slightly larger particles
        }
        self.hammer_hit_effects.append(effect)
```
- T·∫°o 8 h·∫°t (particles) cho m·ªói c√∫ ƒë√°nh, m·ªói h·∫°t c√≥ g√≥c ng·∫´u nhi√™n. T·ªëc ƒë·ªô ng·∫´u nhi√™n (speed) t·ª´ 1 ƒë·∫øn 3 pixel m·ªói frame. T√≠nh to√°n v·∫≠n t·ªëc theo tr·ª•c x (dx) v√† y (dy) d·ª±a tr√™n g√≥c v√† t·ªëc ƒë·ªô.
- `alpha` ƒë∆∞·ª£c kh·ªüi t·∫°o l√† 255 (ho√†n to√†n ƒë·ª•c) khi h·∫°t ƒë∆∞·ª£c t·∫°o ra. N√≥ s·∫Ω ƒë∆∞·ª£c c·∫≠p nh·∫≠t trong ph∆∞∆°ng th·ª©c `update_hammer_hit_effects` ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng m·ªù d·∫ßn khi h·∫°t di chuy·ªÉn v√† bi·∫øn m·∫•t.
---

### Spawn/Despawn Animation

Smooth scale-based animations for zombie appearance and disappearance.

**Methods**:

- `Zombie.get_vertical_offset()` 
- `Zombie.create_spawn_particles()` 
- `Brain.get_alpha()` 

**Features**:

- **Rise animation**: Zombies emerge from ground with eased motion
- **Sink animation**: Zombies sink back when hit or attacking
- **Spawn particles**: Dust and glow effects when zombies appear
- **Brain fade**: Brains fade in/out smoothly
- **Attack animation**: Zombies bounce when attacking

```python
# src/zombie.py
def get_scale_factor(self, now_ms: int) -> float:
    spawn_elapsed = now_ms - self.born_at
    
    # Spawn animation (scale up)
    if spawn_elapsed < self.SPAWN_ANIM_MS:
        progress = spawn_elapsed / self.SPAWN_ANIM_MS
        return progress * 0.8 + 0.2  # Scale from 20% to 100%
    
    # Despawn animation (scale down)
    if self.despawn_start is not None:
        despawn_elapsed = now_ms - self.despawn_start
        if despawn_elapsed < self.DESPAWN_ANIM_MS:
            progress = despawn_elapsed / self.DESPAWN_ANIM_MS
            return (1.0 - progress) * 0.8 + 0.2  # Scale from 100% to 20%
    
    return 1.0  # Normal size
```

# Enhanced Features

## Responsive Design

Window resizing support with scaled UI elements and spawn points.

```python
# main.py
def handle_resize(self, new_width: int, new_height: int) -> None:
    """Handle window resize events with responsive scaling."""
    self.current_width = new_width
    self.current_height = new_height
    self.screen = pygame.display.set_mode((new_width, new_height), pygame.RESIZABLE)
    
    # Recalculate spawn points for new window size
    old_spawn_points = self.spawn_points.copy()
    self.spawn_points = self.make_spawn_points()
    
    # Update scaling factors
    scale_factor = min(new_width / WIDTH, new_height / HEIGHT)
    self.update_entity_scaling(scale_factor)
    self.update_font_scaling(scale_factor)
```

---

## Pause System

Pause-aware timing that excludes paused time from game logic.

```python
# main.py
def get_game_time(self) -> int:
    """Get current game time excluding paused time."""
    wall_time = pygame.time.get_ticks()
    
    if self.paused and self.pause_start_time is not None:
        current_pause_duration = wall_time - self.pause_start_time
        return wall_time - self.total_pause_time - current_pause_duration
    else:
        return wall_time - self.total_pause_time

def toggle_pause(self) -> None:
    if self.paused:
        current_pause_duration = pygame.time.get_ticks() - self.pause_start_time
        self.total_pause_time += current_pause_duration
        self.pause_start_time = None
        self.paused = False
    else:
        self.pause_start_time = pygame.time.get_ticks()
        self.paused = True
```

---

## Brain Pickup System

Collectible items that grant extra lives with priority click handling.

```python
# src/brain.py
def __init__(self, spawn: SpawnPoint, born_at_ms: int) -> None:
    self.spawn = spawn
    self.born_at = born_at_ms
    self.lifetime = BRAIN_LIFETIME_MS
    self.picked_up = False

def contains_point(self, point: tuple[int, int]) -> bool:
    """Check if point is within brain's clickable area."""
    if self.picked_up or self.dead:
        return False
    hitbox_rect = self.get_hitbox_rect()
    return hitbox_rect.collidepoint(point)
```

```python
# src/spawner.py
def maybe_spawn_brain(self, now_ms: int, zombies: list[Zombie], brains: list[Brain]) -> None:
    if now_ms >= self.next_brain_check_at:
        if random.random() < BRAIN_SPAWN_PROBABILITY:
            available_spawns = self.get_available_spawn_points(zombies, brains)
            if available_spawns:
                spawn = random.choice(available_spawns)
                brains.append(Brain(spawn, born_at_ms=now_ms))
```

---

## Debug Visualization

Toggleable hitbox and FPS display for development and testing.

```python
# main.py
def run_game_loop(self) -> None:
    for event in pygame.event.get():
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_f:
                self.show_fps = not self.show_fps
            elif event.key == pygame.K_b:
                self.show_hitboxes = not self.show_hitboxes

def draw(self, now_ms: int, fps: float) -> None:
    # Draw zombies with optional hitboxes
    for z in self.zombies:
        z.draw(self.screen, now_ms)
        if self.show_hitboxes:
            z.draw_hitbox(self.screen, now_ms)
```

```python
# src/zombie.py
def draw_hitbox(self, surf: pygame.Surface, now_ms: int) -> None:
    """Draw hitbox with color-coded states."""
    hitbox_rect = self.get_hitbox_rect(now_ms)
    if self.attacking:
        color = (255, 0, 0)      # Red when attacking (not hittable)
    elif self.hit:
        color = (128, 128, 128)  # Gray when hit
    else:
        color = (0, 255, 0)      # Green when hittable
    pygame.draw.rect(surf, color, hitbox_rect, 2)
```

---

# License

This project is created for educational purposes as part of Assignment 1.

# Contributing

This is an academic project, but suggestions for improvements are welcome!

---

**Happy Zombie Whacking! üßü‚Äç‚ôÇÔ∏èüî®**
